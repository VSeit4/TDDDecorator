assertEquals

assertEquals(4, calculator.multiply(2, 2),"optional failure message");

assertTrue

assertTrue('a' < 'b', () → "optional failure message");

assertFalse

assertFalse('a' > 'b', () → "optional failure message");

assertNotNull

assertNotNull(yourObject, "optional failure message");

assertNull

assertNull(yourObject, "optional failure message");


assertTrue('a' < 'b', () -> "Assertion messages can be lazily evaluated -- "
                + "to avoid constructing complex messages unnecessarily.");

/*
// without static imports you have to write the following statement
import org.junit.jupiter.api.Assertions;
// more code
Assert.assertEquals("10 x 5 must be 50", 50, tester.multiply(10, 5));


// alternatively define assertEquals as static import
import static org.junit.jupiter.api.Assertions.assertEquals;
// more code
// use assertEquals directly because of the static import
assertEquals(calculator.multiply(4,5), 20, "Regular multiplication should work");
 */


 @Test
 void groupedAssertions() {
     Address address = new Address();
     assertAll("address name",
         () -> assertEquals("John", address.getFirstName()),
         () -> assertEquals("User", address.getLastName())
     );
 }

 @Test
 void timeoutNotExceeded() {
     assertTimeout(ofMinutes(1), () -> service.doBackup());
 }

 // if you have to check a return value
 @Test
 void timeoutNotExceededWithResult() {
     String actualResult = assertTimeout(ofSeconds(1), () -> {
         return restService.request(request);
     });
     assertEquals(200, request.getStatus());
 }

 Assumptions.assumeFalse(System.getProperty("os.name").contains("Linux"));


 @ValueSource(ints = { 1, 2, 3 })
 Lets you define an array of test values. Permissible types are String, int, long, or double.

 @EnumSource(value = Months.class, names = {"JANUARY", "FEBRUARY"})
 Lets you pass Enum constants as test class. With the optional attribute names you can choose which constants should be used. Otherwise all attributes are used.

 @MethodSource(names = "genTestData")
 The result of the named method is passed as argument to the test.

 @CsvSource({ "foo, 1", "'baz, qux', 3" })
 void testMethod(String first, int second) {
 Expects strings to be parsed as Csv. The delimiter is ','.

 @ArgumentsSource(MyArgumentsProvider.class)
 Specifies a class that provides the test data. The referenced class has to implement the ArgumentsProvider interface.


 @ParameterizedTest
 @ValueSource(ints = {1, 12, 42})
 void testWithExplicitArgumentConversion(@ConvertWith(ToOctalStringArgumentConverter.class) String argument) {
     System.err.println(argument);
     assertNotNull(argument);
 }

 static class ToOctalStringArgumentConverter extends SimpleArgumentConverter {
     @Override
     protected Object convert(Object source, Class<?> targetType) {
         assertEquals(Integer.class, source.getClass(), "Can only convert from Integers.");
         assertEquals(String.class, targetType, "Can only convert to String");
         return Integer.toOctalString((Integer) source);
     }
 }

 The @Nested annotation can be used to annotate inner classes which also contain tests. This allows to group tests and have additional @BeforeEach method, and one @AfterEach methods. When you add nested test classes to our test class, the following rules must be followed:


 @TestMethodOrder(OrderAnnotation.class)
 class OrderAnnotationDemoTest {

     @Test
     @Order(1)
     void firstOne() {
         // test something here
     }

     @Test
     @Order(2)
     void secondOne() {
         // test something here
     }

 }

     @Test
     @DisplayName("Ensure that two temporary directories with same files names and content have same hash")
     void hashTwoDynamicDirectoryWhichHaveSameContent(@TempDir Path tempDir, @TempDir Path tempDir2) throws IOException {

         Path file1 = tempDir.resolve("myfile.txt");

         List<String> input = Arrays.asList("input1", "input2", "input3");
         Files.write(file1, input);

         assertTrue(Files.exists(file1), "File should exist");

         Path file2 = tempDir2.resolve("myfile.txt");

         Files.write(file2, input);
         assertTrue(Files.exists(file2), "File should exist");

     }
